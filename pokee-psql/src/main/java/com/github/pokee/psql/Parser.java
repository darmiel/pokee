package com.github.pokee.psql;

import com.github.pokee.psql.domain.token.Token;
import com.github.pokee.psql.domain.token.support.TokenType;
import com.github.pokee.psql.domain.tree.nodes.common.NamespacedFieldNode;
import com.github.pokee.psql.domain.tree.nodes.common.TerminalNode;
import com.github.pokee.psql.domain.tree.nodes.expression.*;
import com.github.pokee.psql.domain.tree.nodes.grammar.impl.*;
import com.github.pokee.psql.exception.ParseException;

import java.util.ArrayList;
import java.util.List;

/**
 * The Parser class is responsible for parsing the tokens generated by the lexer and constructing a syntax tree.
 * The syntax tree is used to represent the structure of the query and is used by the interpreter to execute the query.
 */
public class Parser {

    public static final String TRACE_PREFIX = "> ";

    private final Lexer lexer;

    /**
     * Constructs a new Parser instance with the given lexer.
     *
     * @param lexer The lexer to use for tokenizing the query.
     */
    public Parser(final Lexer lexer) {
        this.lexer = lexer;
    }

    /**
     * Constructs a new Parser instance with the given query string.
     *
     * @param query The query string to parse.
     */
    public Parser(final String query) {
        this(new Lexer(query));
    }

    /**
     * Ensures the current token matches the expected type and advances the lexer if it does.
     * Throws an error if the token does not match.
     *
     * @param type   The expected token type.
     * @param reason A custom error message to display if the token does not match.
     * @return The current instance of the Parser for method chaining.
     */
    private Parser expect(final TokenType type, final String reason) throws ParseException {
        if (this.advanceIfNull().current().type() != type) {
            throw ParseException.because(this.lexer, reason, type);
        }
        return this;
    }

    /**
     * Advances the lexer to the next token.
     *
     * @return The current instance of the Parser for method chaining.
     */
    private Parser advance() {
        this.lexer.nextToken();
        return this;
    }

    private Parser advanceIfNull() {
        if (this.current() == null) {
            this.advance();
        }
        return this;
    }

    /**
     * Returns the next token from the lexer without advancing the position.
     *
     * @return The next token.
     */
    private Token peek() {
        return this.lexer.peekToken();
    }

    /**
     * Returns the current token from the lexer without advancing the position.
     *
     * @return The current token.
     */
    private Token current() {
        return this.lexer.getCurrentToken();
    }

    /**
     * Creates a TerminalNode from the current token. A TerminalNode is presumably a part of the parser's
     * syntax tree, representing leaf nodes with actual token values.
     *
     * @return A new TerminalNode initialized with the current token.
     */
    private TerminalNode createTerminalNodeFromCurrentToken() {
        final TerminalNode terminalNode = new TerminalNode();
        terminalNode.setSymbol(this.lexer.getCurrentToken());
        return terminalNode;
    }

    public ProgramContext parseProgram() throws ParseException {
        this.advanceIfNull();

        final List<StatementContext> statements = new ArrayList<>();
        while (this.current().type() != TokenType.EOF) { // parse until the end of the query
            statements.add(this.parseStatement());
        }

        return new ProgramContext(statements);
    }

    /**
     * Parses a statement from the lexer and returns a StatementContext instance.
     *
     * @return A StatementContext instance representing the parsed statement.
     */
    public StatementContext parseStatement() throws ParseException {
        switch (this.lexer.getCurrentToken().type()) {
            case USE -> {
                final UseStatementContext useStatementContext = this.parseUseAliasContext();
                return new StatementContext(useStatementContext, null, null);
            }
            case QUERY -> {
                final QueryContext queryContext = this.parseQueryContext();
                return new StatementContext(null, queryContext, null);
            }
            case LANGUAGE -> {
                final LanguageContext languageContext = this.parseLanguage();
                return new StatementContext(null, null, languageContext);
            }
            default ->
                    throw ParseException.because(this.lexer, "A statement should either be `use`, `query`, or `language`.",
                            TokenType.USE, TokenType.QUERY, TokenType.LANGUAGE);
        }
    }

    /**
     * Parses a `use` statement and returns a UseAliasContext instance.
     *
     * @return A UseAliasContext instance representing the parsed `use` statement.
     */
    public UseStatementContext parseUseAliasContext() throws ParseException {
        this.expect(TokenType.USE, "A use-statement should start with `use`.").advance()
                .expect(TokenType.IDENTIFIER, "You must specify a namespace to use.");
        final TerminalNode original = this.createTerminalNodeFromCurrentToken();

        switch (this.advance().current().type()) {
            case SEMICOLON -> {
                // if a semicolon is found, it means no alias is specified, the namespace is just imported.
                this.advance(); // move past the semicolon
                return new UseStatementContext(original, null);
            }
            case AS -> {
                // if an `as` is found, it means an alias is specified for the namespace.
                this.advance().expect(TokenType.IDENTIFIER, "You must specify an alias after `as`.");
                final TerminalNode alias = this.createTerminalNodeFromCurrentToken();
                this.advance().expectEndOfStatement().advance();
                return new UseStatementContext(original, alias);
            }
            default ->
                    throw ParseException.because(this.lexer, "A use-statement should either end with a semicolon or specify an alias.",
                            TokenType.SEMICOLON, TokenType.AS);
        }
    }

    /**
     * Parses the type of projection based on the current token and updates the list of projections.
     *
     * @param projectionNodeList The list to which new projection nodes are added.
     * @param namespace          The current namespace terminal node.
     * @throws ParseException if unexpected tokens are found.
     */
    private void parseProjectionType(final List<ProjectionNode> projectionNodeList,
                                     final TerminalNode namespace) throws ParseException {
        switch (this.current().type()) {
            case LBRACE -> {
                // A brace projection is a shorthand for selecting multiple fields from a namespace.
                // e.g.: `Pokémon::{name, hp as health}`
                this.advance(); // skip the LBRACE

                this.parseProjectionNodesInBraces(projectionNodeList, namespace);
            }
            case STAR, IDENTIFIER -> {
                // A wildcard projection is used to select all fields in a namespace.
                // e.g.: `Pokémon::*`
                // A single field projection is used to select a single field from a namespace.
                // e.g.: `Pokémon::name`
                final ProjectionNode node = this.parseProjectionNode(namespace);
                projectionNodeList.add(node);
            }
            default -> throw ParseException.because(this.lexer, """
                            Expected either `*`, `{`, or an identifier after the namespace name.
                            You can select all fields using `Pokemon::*` or specify multiple fields using `Pokemon::{field1, field2 as f2}`.""",
                    TokenType.STAR, TokenType.LBRACE, TokenType.IDENTIFIER);
        }
    }

    /**
     * Parses field definitions enclosed in braces.
     *
     * @param projectionNodeList The list to which new projection nodes are added.
     * @param namespace          The current namespace terminal node.
     * @throws ParseException if unexpected tokens are found.
     */
    private void parseProjectionNodesInBraces(final List<ProjectionNode> projectionNodeList,
                                              final TerminalNode namespace) throws ParseException {
        while (this.current().type() != TokenType.RBRACE) {
            final ProjectionNode node = this.parseProjectionNode(namespace);
            projectionNodeList.add(node);

            if (this.current().type() == TokenType.COMMA) {
                this.advance();
            } else if (this.current().type() != TokenType.RBRACE) {
                throw ParseException.because(this.lexer, "Expected either `,` or `}` after a field selection.",
                        TokenType.COMMA, TokenType.RBRACE);
            }
        }
        this.advance(); // Move past the RBRACE
    }

    /**
     * Parses projection nodes from a given query structure.
     * This method supports different formats of projections including:
     * - Wildcard projections (e.g., `P::*`)
     * - Listed fields with optional aliases in braces (e.g., `P::{name, hp}`)
     * - Multiple individual fields with optional aliases (e.g., `P::name, P::hp`)
     *
     * @return A list of ProjectionNode, each representing a parsed field or wildcard from the query.
     * @throws ParseException if the syntax of the projections is incorrect.
     */
    private List<ProjectionNode> parseProjectionNodes() throws ParseException {
        final List<ProjectionNode> projectionNodeList = new ArrayList<>();
        while (true) {
            this.expect(TokenType.NAMESPACE_NAME, """
                    Expected a selection namespace name after query identifier.
                    Use an identifier you have previously used in a `use` statement.
                    For example, `P::{name, hp}` selects the `name` and `hp` fields from the `Pokemon` namespace.""");
            final TerminalNode namespace = this.createTerminalNodeFromCurrentToken();
            this.advance();

            this.parseProjectionType(projectionNodeList, namespace);

            if (this.current().type() == TokenType.COMMA) {
                this.advance();
            } else {
                break;
            }
        }
        return projectionNodeList;
    }

    public ExpressionNode parseExpressionNode() throws ParseException {
        return this.parseLogicalOrExpression();
    }

    private ExpressionNode parseLogicalOrExpression() throws ParseException {
        ExpressionNode lhs = this.parseLogicalAndExpression();
        while (this.current().type() == TokenType.BOOL_OR) {
            this.advance(); // move past the operator

            final ExpressionNode rhs = this.parseLogicalAndExpression();
            lhs = new BinaryExpressionNode(lhs, rhs, TokenType.BOOL_OR);
        }
        return lhs;
    }

    private ExpressionNode parseLogicalAndExpression() throws ParseException {
        ExpressionNode lhs = this.parseEqualityExpression();
        while (this.current().type() == TokenType.BOOL_AND) {
            this.advance(); // move past the operator

            final ExpressionNode rhs = this.parseEqualityExpression();
            lhs = new BinaryExpressionNode(lhs, rhs, TokenType.BOOL_AND);
        }
        return lhs;
    }

    private ExpressionNode parseEqualityExpression() throws ParseException {
        ExpressionNode lhs = this.parseRelationalExpression();
        while (this.current().type() == TokenType.CMP_EQUALS || this.current().type() == TokenType.CMP_NOT_EQUALS) {
            final TokenType operator = this.current().type();
            this.advance(); // move past the operator

            final ExpressionNode rhs = this.parseRelationalExpression();
            lhs = new BinaryExpressionNode(lhs, rhs, operator);
        }
        return lhs;
    }

    private ExpressionNode parseRelationalExpression() throws ParseException {
        ExpressionNode lhs = this.parsePrimaryExpression();
        while (this.current().type().isCompareOperator()) {
            final TokenType operator = this.current().type();
            this.advance(); // move past the operator

            final ExpressionNode rhs = this.parsePrimaryExpression();
            lhs = new BinaryExpressionNode(lhs, rhs, operator);
        }
        return lhs;
    }

    private ExpressionNode parseLiteralExpression() throws ParseException {
        final TokenType type = this.current().type();
        final TerminalNode terminalNode = this.createTerminalNodeFromCurrentToken();
        this.advance();
        return new LiteralExpressionNode(type, terminalNode);
    }

    private ExpressionNode parseFunctionOrIdentifierExpression() throws ParseException {
        // expect and parse the field with the namespace name
        final NamespacedFieldNode fieldNode = this.parseNamespacedField();

        // a dot indicates a function call
        if (this.current().type() == TokenType.DOT) {
            this.advance() // go to the function name
                    .expect(TokenType.FUNCTION_NAME, "Expected a function name after the dot.");

            final TerminalNode functionName = this.createTerminalNodeFromCurrentToken();
            this.advance();

            this.expect(TokenType.LPAREN, "Expected an opening parenthesis after the function name.").advance();
            final List<TerminalNode> arguments = this.parseFunctionArguments();
            this.expect(TokenType.RPAREN, "Expected a closing parenthesis after the function arguments.").advance();

            return new FunctionCallExpressionNode(fieldNode, functionName.getText(), arguments);
        }

        // if there is a compare operator, treat the current expression as an identifier
        if (this.current().type().isCompareOperator()) {
            return new IdentifierExpressionNode(fieldNode);
        }

        throw ParseException.because(this.lexer, """
                Expected either a function call or a comparison after the namespace and target field.
                You can call a function using `P::name.startsWith("Pika")` or compare fields using `P::name == "Pikachu`.""");
    }

    public ExpressionNode parsePrimaryExpression() throws ParseException {
        switch (this.current().type()) {
            case LPAREN -> {
                this.advance();

                final ExpressionNode expression = this.parseExpressionNode();
                this.expect(TokenType.RPAREN, "Expected a closing parenthesis after the expression.");
                this.advance(); // move past the closing parenthesis

                return expression;
            }
            case NAMESPACE_NAME -> {
                return this.parseFunctionOrIdentifierExpression();
            }
        }
        if (this.current().type().isLiteral()) {
            return this.parseLiteralExpression();
        }
        throw ParseException.because(this.lexer, """
                Expected either a literal value, a namespace name, or an opening parenthesis to start an expression.
                You can use literals like strings, numbers, and booleans, call functions, or compare fields using `P::name == "Pikachu`.""");
    }

    public QueryContext parseQueryContext() throws ParseException {
        this.expect(TokenType.QUERY, "Expected `query` to start a query statement.")
                .advance();

        // read the query name
        this.expect(TokenType.IDENTIFIER, """
                Expected a query name after `query`.
                This name will be used to identify the result of the query in the output.""");
        final TerminalNode queryName = this.createTerminalNodeFromCurrentToken();
        this.advance();

        final List<ProjectionNode> projectionNodeList = this.parseProjectionNodes();
        System.out.println(projectionNodeList);

        // make sure if there is an `all` projection node, it is the only one
        if (projectionNodeList.stream().anyMatch(ProjectionNode::isAll) && projectionNodeList.size() > 1) {
            throw ParseException.because(this.lexer, "You can only use `*` once in a query.");
        }

        final List<ExpressionNode> filterExpressions = new ArrayList<>();
        while (this.current().type() == TokenType.FILTER) {
            this.advance(); // go past the filter keyword

            final ExpressionNode filterExpression = this.parseExpressionNode();
            filterExpressions.add(filterExpression);
        }

        this.expectEndOfStatement()
                .advance();

        return new QueryContext(queryName, projectionNodeList, filterExpressions);
    }

    private Parser expectEndOfStatement() throws ParseException {
        if (this.current().type() != TokenType.SEMICOLON && this.current().type() != TokenType.EOF) {
            throw ParseException.because(this.lexer, "Expected a semicolon to end the statement.");
        }
        return this;
    }


    /**
     * Parses a projection node from the current token and returns a ProjectionNode instance.
     * A projection node is used to select fields from a namespace and optionally alias them.
     * <p>
     * A projection node can be a wildcard projection (e.g., `Pokémon::*`) or a field projection.
     * <p>
     * A single field projection can be aliased (e.g., `Pokémon::{name as n}`) or not aliased (e.g., `Pokémon::name`).
     * <pre>
     *     Pokémon::name as n
     *     │^^^^^^   │^^^    │
     *     │         │       └▶ Alias
     *     │         └────▶ Field
     *     └─▶ Namespace
     * </pre>
     * <p>
     * A wildcard is represented by a star after the namespace and cannot be aliased.
     * <pre>
     *     Pokémon::*
     *     │^^^^^^  │
     *     │        └▶ Wildcard
     *     └─▶ Namespace
     * </pre>
     *
     * @param namespace The current namespace terminal node.
     * @return A ProjectionNode instance representing the parsed projection.
     * @throws ParseException if the syntax of the projection is incorrect.
     */
    private ProjectionNode parseProjectionNode(final TerminalNode namespace) throws ParseException {
        // for wildcard projections, the field is `null` and the alias is `null`.
        // the projection can be either `Pokémon::{*}` or `Pokémon::*`.
        if (this.current().type() == TokenType.STAR) {
            this.advance(); // skip the star, we don't need it anymore

            // make sure the user doesn't try to alias a wildcard projection
            // because how the fck should this work? I am not allowed to swear because Copilot decides to turn off.
            if (this.current().type() == TokenType.AS) {
                throw ParseException.because(this.lexer, """
                        You cannot alias a wildcard projection.
                        You can select all fields using `Pokemon::*` or specify multiple fields using `Pokemon::{field1, field2 as f2}`.""");
            }

            // This field doesn't select a specific field, so we can set field to `null`.
            // The NamespacedFieldNode supports null fields for wildcard projections.
            final NamespacedFieldNode field = new NamespacedFieldNode(namespace, null);
            return new ProjectionNode(field, null);
        }

        // a field projection can be either `Pokémon::{name}` or `Pokémon::name`.
        if (this.current().type() == TokenType.IDENTIFIER) {
            final TerminalNode fieldName = this.createTerminalNodeFromCurrentToken();
            this.advance(); // move past the field name

            TerminalNode alias = null;

            // since this is a field projection, the user can specify an alias.
            if (this.current().type() == TokenType.AS) {
                this.advance().expect(TokenType.IDENTIFIER, "Expected an alias after `as`.");
                alias = this.createTerminalNodeFromCurrentToken();
                this.advance(); // move past the alias
            }

            final NamespacedFieldNode field = new NamespacedFieldNode(namespace, fieldName);
            return new ProjectionNode(field, alias);
        }

        throw ParseException.because(this.lexer, """
                        Expected either a field name or `*` after the namespace name.
                        You can select all fields using `Pokemon::*` or specify multiple fields using `Pokemon::{field1, field2 as f2}`.""",
                TokenType.IDENTIFIER, TokenType.STAR);
    }

    /**
     * Parses arguments for a function call and returns a list of terminal nodes representing the arguments.
     * The arguments can be any literal value (e.g., string, number, boolean) and are separated by commas.
     * A function call can have multiple arguments separated by commas.
     *
     * <pre>
     *     P::name.startsWith() // valid
     *     P::name.startsWith("Pika", "chu") // valid
     *     P::name.startsWith("Pika" "chu") // invalid
     * </pre>
     *
     * @return A list of terminal nodes representing the function arguments.
     * @throws ParseException if the syntax of the function arguments is incorrect.
     */
    private List<TerminalNode> parseFunctionArguments() throws ParseException {
        final List<TerminalNode> args = new ArrayList<>();

        // if there's already a closing parenthesis, we can early return! :)
        // e.g. `P::name.startsWith()`
        if (this.current().type() == TokenType.RPAREN) {
            return args;
        }

        do {
            // currently, we only support literal values as arguments.
            // because expressions would be a _bit_ overkill for now, we already exceeded the scope of the project.
            if (!this.current().type().isLiteral()) {
                throw ParseException.because(this.lexer, """
                                Expected a literal value as a function argument.
                                You can use strings, numbers, and booleans as function arguments.""",
                        TokenType.STRING_LITERAL, TokenType.NUMBER, TokenType.BOOL_TRUE, TokenType.BOOL_FALSE);
            }

            // e.g. `P::name.startsWith("Pika")`
            //                          ^^^^^^
            args.add(this.createTerminalNodeFromCurrentToken());
            this.advance();  // move past the literal

            // if the next token is a comma, skip it and check for another argument.
            // e.g. `P::name.startsWith("Pika", "chu")`
            //                                ^
            if (this.current().type() == TokenType.COMMA) {
                this.advance();  // Move past the comma.
            } else if (this.current().type() != TokenType.RPAREN) {
                // if the next token is not a closing parenthesis, it's an invalid token.
                throw ParseException.because(this.lexer, "Expected a comma or a closing parenthesis in function arguments.",
                        TokenType.COMMA, TokenType.RPAREN);
            }
        } while (this.current().type() != TokenType.RPAREN); // continue until reaching the closing parenthesis.

        return args;
    }

    /**
     * Parses a language statement and returns a LanguageContext instance.
     * A language statement is used to specify the language in which the query is written.
     * <p>
     * At the end of the statement (or EOF), a semicolon is expected to terminate the statement and the lexer moves past
     * the semicolon.
     *
     * <pre>
     *     lang de;
     *     │^^^ │^└▶End of Statement
     *     │    │
     *     │    └▶Language
     *     │
     *     └▶Language Keyword
     * </pre>
     *
     * @return A LanguageContext instance representing the parsed language statement.
     * @throws ParseException if the syntax of the language statement is incorrect.
     */
    public LanguageContext parseLanguage() throws ParseException {
        this.expect(TokenType.LANGUAGE, "Expected `language` to start a language statement.").advance()
                .expect(TokenType.IDENTIFIER, "Expected a language name after `language`.");

        final TerminalNode language = this.createTerminalNodeFromCurrentToken();
        this.advance().expectEndOfStatement().advance();

        return new LanguageContext(language);
    }

    /**
     * Parses a namespaced field expression. A namespaced field expression is a combination of a namespace and a field
     * name, optionally followed by a wildcard `*` to select all fields in the namespace.
     * <p>
     * The end result is a NamespacedFieldNode instance representing the parsed expression and the lexer moves past the
     * field name.
     *
     * <pre>
     *                  ┌ Field ─┐
     *                ┌▶│name    │
     * ┌ Namespace ─┐ │ └────────┘
     * │Pokemon::   │─┤
     * └────────────┘ │ ┌ Wildcard ─┐
     *         one of └▶│*          │
     *                  └───────────┘
     * </pre>
     *
     * @return A NamespacedFieldNode instance representing the parsed namespaced field expression.
     * @throws ParseException if the syntax of the namespaced field expression is incorrect.
     */
    public NamespacedFieldNode parseNamespacedField() throws ParseException {
        this.expect(TokenType.NAMESPACE_NAME, """
                Expected a namespace name to start an expression. Use an identifier you have previously used in a `use` statement.
                Example: P::name, where `P` is a namespace you have previously imported and `name` is a field in that namespace.""");
        final TerminalNode namespace = this.createTerminalNodeFromCurrentToken();
        this.advance();

        if (this.current().type() == TokenType.IDENTIFIER) {
            // Pokemon::name
            // ^^^^^^^  ^^^^
            // │        └▶Field Name
            // └─▶Namespace
            final TerminalNode target = this.createTerminalNodeFromCurrentToken();
            this.advance();
            return new NamespacedFieldNode(namespace, target);
        }

        if (this.current().type() == TokenType.STAR) {
            // Pokemon::*
            // ^^^^^^^  ^
            // │        └▶Wildcard
            // └─▶Namespace
            this.advance();
            return new NamespacedFieldNode(namespace, null);
        }

        throw ParseException.because(this.lexer, """
                        Expected either a target field or `*` after the namespace name.
                        You can select all fields using `Pokemon::*` or specify a single field using `Pokemon::name`.""",
                TokenType.IDENTIFIER, TokenType.STAR);
    }

}
